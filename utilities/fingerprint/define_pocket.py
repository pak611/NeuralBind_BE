
try:

    from openbabel import openbabel as ob
except ImportError:
    import openbabel as ob
import sys
import os
import numpy as np
import pickle

from model.obbl import Molecule
from model.toolkits.spatial import angle, distance
from model.toolkits.interactions import hbonds, pi_stacking, salt_bridges, \
    hydrophobic_contacts, close_contacts, halogenbonds
from model.toolkits.pocket import surface_atoms
from model.IFP import cal_Interactions
from pathos.multiprocessing import Pool
from functools import partial
from tqdm.auto import tqdm

print('CALLING DEFINE POCKET')




from model.toolkits.parse_tool import parseReceptor, parseVinaConfig, parseLigConfig



def saveObj(obj, name):
    '''saves the pickle file containing the 'reference atoms 1(reference) 0(not reference)'''

    os.chdir(f'{os.getcwd()}\\utilities\\fingerprint')
    os.system('mkdir obj')
    os.chdir('../../')
    with open(os.getcwd() + '\\utilities\\fingerprint\\obj\\' + name + '.pkl', 'wb') as f:
        pickle.dump(obj, f, pickle.HIGHEST_PROTOCOL)



def pocketAtoms(x, y, cutoff, x_column='coords', y_column='coords',
                 cutoff_low=0.):
    """Returns pairs of atoms which are within close contac distance cutoff.
    The cutoff is semi-inclusive, i.e (cutoff_low, cutoff].

    Parameters
    ----------
    x, y : atom_dict-type numpy array
        Atom dictionaries generated by oddt.toolkit.Molecule objects.

    cutoff : float
        Cutoff distance for close contacts

    x_column, ycolumn : string, (default='coords')
        Column containing coordinates of atoms (or pseudo-atoms,
        i.e. ring centroids)

    cutoff_low : float (default=0.)
        Lower bound of contacts to find (exclusive). Zero by default.
        .. versionadded:: 0.6

    Returns
    -------
    x_, y_ : atom_dict-type numpy array
        Aligned pairs of atoms in close contact for further processing.
    """
    if len(x[x_column]) > 0 and len(x[x_column]) > 0:
        d = distance(x[x_column], y[y_column])
        index = np.argwhere((d > cutoff_low) & (d <= cutoff))
        return index[:, 0]
    else:
        return []

def collectOutFiles(referLigandsFolder):
    suffix = '_out.pdbqt'
    processed = [] # initialize empty files list
    files = os.listdir(referLigandsFolder)
    for file in files:
        baseName = os.path.basename(file)
        simpleName = baseName.replace('_', '.').split('.') # returns a list of filename words split
        simpleName = simpleName[0]
        processed.append({
            'simpleName': simpleName,
            'baseName': baseName,
            'fullName': file
        }) # list of dictionary values?

        return processed

'''
def detectPocketAtom(ligand, pAtomDict, refer_ligands_folder):
    ligand_name = ligand['simple_name']
    print(f'{ligand_name} is being processing!')
    ligand = parseVinaConfig(os.path.join(
        refer_ligands_folder, ligand['base_name']))
    ligand_poses = ligand['docked_ligands']
    PocketAtoms_mult = []
    for ipose in range(len(ligand_poses)):
        mol_l = Molecule(ligand_poses[ipose], protein=False)
        l_atomdict = mol_l.atom_dict
        PocketAtoms = pocketAtoms(pAtomDict, l_atomdict, 3.0)
        # print(f'pocket_atoms: \n {PocketAtoms}')
        PocketAtoms_mult = PocketAtoms_mult+list(PocketAtoms)
        PocketAtoms_mult = list(set(PocketAtoms_mult))
    return PocketAtoms_mult

'''
def detectPocketAtom(ligand, pAtomDict, referLigandsFolder):
    
    ligand = parseLigConfig(os.path.join(referLigandsFolder, ligand['baseName']))
    ligandPoses = ligand['docked_ligands']
    PocketAtomsMult = []
    for ipose in range(len(ligandPoses)):
        molL = Molecule(ligandPoses[ipose], protein=False)
        lAtomdict = molL.atom_dict
        PocketAtoms = pocketAtoms(pAtomDict, lAtomdict, 3.0)
        # print(f'pocket_atoms: \n {PocketAtoms}')
        PocketAtomsMult = PocketAtomsMult+list(PocketAtoms)
        PocketAtomsMult = list(set(PocketAtomsMult))
    return PocketAtomsMult




def main(config):

    # initialize the interaction dictionary

    intDict = {'hbond': '',
                'halogen': '',
                'elecpair': '',
                'hydrophobic': '',
                'pipi':''
                }

    receptor = config['receptor']
    referLigandsFolder = config['referLigandsFolder']
    ligands = collectOutFiles(referLigandsFolder=referLigandsFolder)
    receptor = parseReceptor(receptor)
    molP = Molecule(receptor['receptor'], protein=True) # Molecule object containing the receptor
    
    pocketAtomsMult = []
    pAtomDict = molP.atom_dict


    # for parallel computing


    with Pool(40) as pool:
        detectPocketAtomP = partial(
            detectPocketAtom, pAtomDict=pAtomDict, referLigandsFolder=referLigandsFolder)
        pAtom_list = [x for x in tqdm(
            pool.imap(detectPocketAtomP, list(ligands)),
            total=len(ligands),
            miniters=50
        )
            if x is not None]




    for iPatom in pAtom_list:
        pocketAtomsMult.extend(iPatom)
    pocketAtomsMult = list(set(pocketAtomsMult))
    print(f'\nPocketAtomsMult: \n {pocketAtomsMult}\n')

       # refer_atoms = [x for x in PocketAtoms_mult if x in SurfaceAtoms]
    referAtoms = pocketAtomsMult
    referAtoms.sort()
    print(f'\nNumber of reference atoms:  {len(referAtoms)}\n')
    print(f'\nreferAtoms:\n  {referAtoms}\n')
    referRes = []
    for atmidx in referAtoms:
        resName = pAtomDict[atmidx][11]
        resNum = pAtomDict[atmidx][10]
        referRes.append(f'{resName}_{resNum}')
    referRes = list(set(referRes))
    referRes.sort()

    saveObj(referAtoms, 'referAtomsList')
    saveObj(referRes, 'referResList')
    print(f'\nNumber of reference residues:  {len(referRes)}\n')
    print(f'\nreferRes:\n {referRes}\n')


    #----------------------------------




    # could pool call to partial function for IFP here







if __name__ == "__main__":

    # args is actually a namespace
    args = 'C:\\Users\\patri\\Dropbox\\Ph.D\\OrganoNet\\NeuralBind\\utilities\\fingerprint\\config_files\\config_ifp.txt'
    config = parseVinaConfig(args)
    main(config)



